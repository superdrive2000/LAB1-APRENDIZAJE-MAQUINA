---
title: "LAB 2"
author: "Jesus Quinga"  
format: "html"
code-fold: false    
#format:
#    html:
#        embed-resources: true

#AQUI PONER EL PATH HACIA SU AMBIENTE VIRTUAL
execute:
  python: C:/Users/Lenovo i5/Documents/MAESTRIA IA YACHAY TECH/APRENDIZAJE DE MAQUINA/SEMANA 1/.venv/Scripts/python.exe
---
```{python}
import pandas as pd
import matplotlib.pyplot as plt


from sklearn.model_selection import train_test_split
from sklearn.naive_bayes import MultinomialNB
from sklearn.pipeline import Pipeline
from sklearn.metrics import classification_report, confusion_matrix, ConfusionMatrixDisplay
# vectorizacion textual

from sklearn.feature_extraction.text import TfidfTransformer
from sklearn.feature_extraction.text import CountVectorizer
import nltk
from nltk.corpus import stopwords

nltk.download('stopwords') # necessary for removal of stop words
nltk.download('wordnet') # necessary for lemmatization
from sklearn.preprocessing import LabelEncoder


```

# Cargar Data


```{python}

url = "https://raw.githubusercontent.com/erickedu85/dataset/refs/heads/master/tweets/tweets_totales_con_sentimiento_ml.csv"
df = pd.read_csv(url)
df.head()
```

# Creacción de columan target


```{python}
df['sentiment_label'] = df['sentiment_polarity'].apply(
    lambda x: 'negativo' if x < 0 else ('neutral' if x == 0 else 'positivo')
)
df


```

```{python}
# Contar la cantidad de valores por clase
counts = df['sentiment_label'].value_counts()

# Mostrar la cuenta en consola
print(counts)

# Crear gráfico de barras
plt.figure(figsize=(6,4))
counts.plot(kind='bar', color=['red', 'gray', 'green'])
plt.title('Cantidad de tweets por clase de sentimiento')
plt.xlabel('Clase de sentimiento')
plt.ylabel('Cantidad de registros')
plt.xticks(rotation=0)
plt.show()
```

Existe una frecuecia de 92% neutral 2% positivo y 2% negativo. Por lo que se eligira un dataset mas pequeño por submuestreo. De tal forma que tengamos el mismo procentaje en cada clase


```{python}

# Calcular el tamaño mínimo de las clases
min_count = df['sentiment_label'].value_counts().min()

# Crear un dataset balanceado por submuestreo
df_balanced = (
    df.groupby('sentiment_label', group_keys=False)
      .apply(lambda x: x.sample(min_count, random_state=42))
)

df_balanced

```

```{python}
# Contar la cantidad de valores por clase
counts = df_balanced['sentiment_label'].value_counts()

# Mostrar la cuenta en consola
print(counts)

# Crear gráfico de barras
plt.figure(figsize=(6,4))
counts.plot(kind='bar', color=['red', 'gray', 'green'])
plt.title('Cantidad de tweets por clase de sentimiento')
plt.xlabel('Clase de sentimiento')
plt.ylabel('Cantidad de registros')
plt.xticks(rotation=0)
plt.show()

```




Codificamos la columna de target:




```{python}
le = LabelEncoder()
df_balanced['sentiment_encoded'] = le.fit_transform(df_balanced['sentiment_label'])
df_balanced.head()

```

# Limpieza del twit
Eliminamos menciones
```{python}
df_balanced['content'] = df_balanced['content'].str.replace(r'@\w+', '', regex=True)

```

Eliinamos emojis


```{python}
import emoji

df_balanced['content'] = df_balanced['content'].apply(lambda x: emoji.replace_emoji(x, replace=''))
```

# Seleccion de X e y


```{python}
X_text = df_balanced['content']
y = df_balanced['sentiment_encoded']
```

# Train test


```{python}

X_train,X_test,y_train,y_test = train_test_split(X_text,y,test_size=0.2,random_state=42,stratify=y)
```


# Vectorizacion de text

```{python}

stopwords = stopwords.words('spanish')
vectorizer = CountVectorizer(stop_words=stopwords) #TfidfTransformer()
#vectorizer = TfidfTransformer(stop_words=stopwords)
```

# Definición del Pipeline

```{python}
model = MultinomialNB()
```


```{python}
pipeline = Pipeline(
    [
        ('vectorizacion',vectorizer),
        ('classifier',model)
    ]

)
```

# Fit del modelo


```{python}
pipeline.fit(X_train,y_train)
```

# Predicción


```{python}|
y_pred = pipeline.predict(X_test)

```

# Reporte de clasificación


```{python}
y_pred = pipeline.predict(X_test)

print("Reporte de classificacion\n",classification_report(y_test,y_pred,target_names=df_balanced['sentiment_label'].unique()))
```

# Matriz de confusión

```{python}
ConfusionMatrixDisplay(confusion_matrix(y_test,y_pred),display_labels=df_balanced['sentiment_label'].unique()).plot()

```